
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Determining Enhancement and Polarisation from DNP</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-12-12"><meta name="DC.source" content="findpol.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Determining Enhancement and Polarisation from DNP</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#3">Inputs</a></li><li><a href="#17">Outputs</a></li><li><a href="#20">Child Functions</a></li><li><a href="#29">Calling the User if Insufficient or Invalid Inputs</a></li><li><a href="#30">Calculating Polarisation at Thermal Equilibrium</a></li><li><a href="#31">Calculating the Angle Adjustment Factor and Hyperpolarisation Signal</a></li><li><a href="#34">Determining the Flip Angle Used at the First Measured Point in the Hyperpolarised Dissolution Experiment</a></li><li><a href="#35">Determining the Number of Averages in the Thermal Equilibrium Experiment</a></li><li><a href="#36">Determining the Flip Angle Used in the Thermal Equilibrium Experiment</a></li><li><a href="#37">Determining the Noise in Both Experiments</a></li><li><a href="#38">Calculating the Enhancement Factor and Polarisation of Each Measured Peak</a></li><li><a href="#40">Notes</a></li></ul></div><p><i>findpol</i> calculates the enhancement factor and polarisation of a compound using dissolution data and thermal equilibrium data. From the magnetic field, element and temperature, the polarisation at thermal equilibrium is also calcualted</p><h2 id="3">Inputs</h2><p><i>B0</i>: is the magnetic field strength of the magnet where the experiments were done in Tesla</p><p><i>atom</i>: is the abbreviation of the element detected in the magnet. See <i>findgyro</i> for a list of supported elements</p><p><i>tempc</i>: is the temperature the experiments were conducted in Celsius</p><p><i>inph</i>: is 'A' if the data from the hyperpolarsied dissolution experiment was quantified using AMARES from JMRUI, or it is 'M' if the data was quantified using integration from MestReNova</p><p><i>dath</i>: is either a cell containing the .txt AMARES exports for the data from the hyperpolarised dissolution experiment in each element, or it is a character vector of the .csv integral custom output from MestReNova</p><p><i>procparh</i>: is the procpar file for the hyperpolarised dissolution experiment</p><p><i>inpt</i>: is 'A' if the data from the thermal equilibrium experiment was quantified using AMARES from JMRUI, or it is 'M' if the data was quantified using integration from MestReNova</p><p><i>datt</i>: is either a cell containing the .txt AMARES exports for the data from the thermal equilibrium experiment in each element, or it is a character vector of the .csv integral custom output from MestReNova</p><p><i>procpart</i>: is the procpar file for the thermal equilibrium experiment</p><p><i>FIDs</i>: is a cell containing the .txt outputs from the Mrui output from JMRUI. Each element contains the FID data of the hyperpolarised data and the thermal equilibrium data respectively.</p><p><i>coilnumh</i>: should be left blank or equal to [] unless <i>inph</i> is set to 'M'. If <i>inph</i> is set to 'M', <i>coilnumh</i> is the number of coils used to collect the data for the hyperpolarised experiemnt</p><p><i>fieldh</i>: should be left blank or equal to [] unless <i>inph</i> is set to 'M'. If <i>inph</i> is set to 'M', <i>fieldh</i> is a cell containing the names of each peak quantified in each element</p><p><i>coilnumt</i>: should be left blank or equal to [] unless <i>inpt</i> is set to 'M'. If <i>inph</i> is set to 'M', <i>coilnumt</i> is the number of coils used to collect the data for the thermal equilibrium experiment</p><p><i>fieldt</i>: should be left blank or equal to [] unless <i>inpt</i> is set to 'M'. If <i>fieldt</i> is set to 'M', <i>fieldt</i> is a cell containing the names of each peak quantified in each element</p><h2 id="17">Outputs</h2><p><i>enhance</i>: is an array containing the enhancement factors for each peak</p><p><i>pol</i>: is an array containing the polarisation of each peak at the first measurement in the hyperpolarised dissolution experiment</p><p><i>poltherm</i>: is the polarisation of the compound at thermal equilibrium</p><h2 id="20">Child Functions</h2><p><i>isnumber</i>: checks if an input is a number</p><p><i>findgyro</i>: finds the gyromagnetic ratio from the inputted element abbreviation</p><p><i>findThermalEqPol</i>: calculates the polarisation of the sample at thermoequilibrium given the magnetic field strength, gyromagnetic ratio and temperature</p><p><i>T1DecayCalc</i>: calculates the flip angle correction factor to be applied to the hyperpolarised and thermal equilibrium data to transform the signal data to their respective M0s</p><p><i>alphaparse</i>: parses data collected from the 300MHz magnet to readible arrays</p><p><i>flipAnglesFromProcpar</i>: finds what is stored in the <i>flip1</i> parameter of an inputted procpar file to find the estimated flip angles used</p><p><i>readprocpar</i>: parses an inputted procpar file into a structure array</p><p><i>findNoise</i>: finds the noise from a .txt mRUI output file from JMRUI to calculate the SNR. The noise is assumed to be the standard deviation of the last eighth of the points collected from the time domain</p><pre class="codeinput"><span class="keyword">function</span> [enhance,pol,poltherm] = findpol(B0,atom,tempc,inph,dath,procparh,inpt,datt,procpart,FIDs,coilnumh,fieldh,coilnumt,fieldt)
</pre><h2 id="29">Calling the User if Insufficient or Invalid Inputs</h2><p>The magnetisation <i>B0</i>, must be a number. <i>atom</i> must be a character vector, where the gyromagnetic ratio is stored in <i>findgyro</i>. <i>tempc</i>, the temperature the experiments are done at must a number, like <i>B0</i>.</p><pre class="codeinput">    magbool = 0;
    tempcbool = 0;

    <span class="keyword">if</span> nargin &gt; 0
        magbool = isnumber(B0);
    <span class="keyword">end</span>

    <span class="keyword">while</span> magbool == 0

        <span class="keyword">try</span>
            B0 = input(<span class="string">'Enter the magnetic field strength in Tesla the experiment was conducted in: '</span>);
        <span class="keyword">catch</span>
            disp(<span class="string">'Error: Magnetic field strength must be a number'</span>)
        <span class="keyword">end</span>

        magbool = isnumber(B0);

    <span class="keyword">end</span>

    <span class="keyword">if</span> nargin &gt; 1
        gyro = findgyro(atom);
    <span class="keyword">else</span>
        gyro = findgyro;
    <span class="keyword">end</span>

    <span class="keyword">if</span> nargin &gt; 2
        tempcbool = isnumber(tempc);
    <span class="keyword">end</span>

    <span class="keyword">while</span> tempcbool == 0

        <span class="keyword">try</span>
            tempc = input(<span class="string">'Enter the temperature in Celsius the experiment was conducted in: '</span>);
        <span class="keyword">catch</span>
            disp(<span class="string">'Error: Temperature must be a number'</span>)
        <span class="keyword">end</span>

        tempcbool = isnumber(tempc);

    <span class="keyword">end</span>
</pre><h2 id="30">Calculating Polarisation at Thermal Equilibrium</h2><pre class="codeinput">    poltherm = findThermalEqPol(B0,gyro,tempc);
</pre><h2 id="31">Calculating the Angle Adjustment Factor and Hyperpolarisation Signal</h2><p>When <i>flip1</i> is arrayed, the angles arrayed are an estimate of the used flip angle from varying power. In a dissolution experiment where the flip angles are varied, the data can be described by the following relation:</p><p><img src="findpol_eq13038192646142982952.png" alt="$$ Mxy (Signal)_{at a time} = Mz_{at previous time measursed} \times cos(alpha \times flip1_{previous~time~measured}) \times exp(-TR/T1) \times sin(alpha \times flip1_{at~time}) $$"></p><p><i>T1DecayCalc</i> calculates the parameters: <i>M0</i> (<i>Mz</i> at time = 0), <i>alpha</i> and <i>T1</i>. The variable <i>alpha</i> is the angles adjustment factor that is used to adjustment the proposed flip angles in <i>flip1</i> to the actual flip angles used.</p><pre class="codeinput">    <span class="keyword">if</span> nargin &gt;= 12
        [~,~,alpha] = T1DecayCalc(procparh,inph,dath,coilnumh,fieldh);
        [~,hypersig] = alphaparse([],inph,<span class="string">'N'</span>,dath,coilnum,field,procparh);
    <span class="keyword">elseif</span> nargin &gt;= 11
        [~,~,alpha] = T1DecayCalc(procparh,inph,dath,coilnumh);
        [~,hypersig] = alphaparse([],inph,<span class="string">'N'</span>,dath,coilnum,[],procparh);
    <span class="keyword">elseif</span> nargin &gt;= 6
        [~,~,alpha] = T1DecayCalc(procparh,inph,dath);
        [~,hypersig] = alphaparse([],inph,<span class="string">'N'</span>,dath,[],[],procparh);
    <span class="keyword">elseif</span> nargin &gt;= 5
        [~,~,alpha] = T1DecayCalc([],inph,dath);
        [~,hypersig] = alphaparse([],inph,<span class="string">'N'</span>,dath);
    <span class="keyword">elseif</span> nargin &gt;= 4
        [~,~,alpha] = T1DecayCalc([],inph);
        [~,hypersig] = alphaparse([],inph,<span class="string">'N'</span>);
    <span class="keyword">else</span>
        [~,~,alpha] = T1DecayCalc;
        [~,hypersig] = alphaparse([],[],<span class="string">'N'</span>);
    <span class="keyword">end</span>
</pre><pre class="codeoutput">
Local minimum possible.

lsqcurvefit stopped because the final change in the sum of squares relative to 
its initial value is less than the value of the function tolerance.

</pre><h2 id="34">Determining the Flip Angle Used at the First Measured Point in the Hyperpolarised Dissolution Experiment</h2><pre class="codeinput">    <span class="keyword">if</span> nargin &gt;= 6
        flips = flipAnglesFromProcpar(procparh);
        fliph = flips(1);
    <span class="keyword">else</span>
        flips = flipAnglesFromProcpar;
        fliph = flips(1);
    <span class="keyword">end</span>
</pre><h2 id="35">Determining the Number of Averages in the Thermal Equilibrium Experiment</h2><pre class="codeinput">    <span class="keyword">if</span> nargin &gt;= 14
        [~,thermalsig] = alphaparse([],inpt,<span class="string">'N'</span>,datt,coilnumt,fieldt,procpart);
        numavs = readprocpar(procpart).ct;
    <span class="keyword">elseif</span> nargin &gt;= 13
        [~,thermalsig] = alphaparse([],inpt,<span class="string">'N'</span>,datt,coilnumt,[],procpart);
        numavs = readprocpar(procpart).ct;
    <span class="keyword">elseif</span> nargin &gt;= 9
        [~,thermalsig] = alphaparse([],inpt,<span class="string">'N'</span>,datt,[],[],procpart);
        numavs = readprocpar(procpart).ct;
    <span class="keyword">elseif</span> nargin &gt;= 8
        procpart = readprocpar;
        [~,thermalsig] = alphaparse([],inpt,<span class="string">'N'</span>,datt,[],[],procpart);
        numavs = readprocpar(procpart).ct;
    <span class="keyword">elseif</span> nargin &gt;= 7
        procpart = readprocpar;
        [~,thermalsig] = alphaparse([],inpt,<span class="string">'N'</span>,[],[],[],procpart);
        numavs = readprocpar(procpart).ct;
    <span class="keyword">else</span>
        procpart = readprocpar;
        [~,thermalsig] = alphaparse([],[],<span class="string">'N'</span>,[],[],[],procpart);
        numavs = readprocpar(procpart).ct;
    <span class="keyword">end</span>

    numpeak = length(thermalsig);

    enhance = zeros(numpeak,1);
</pre><h2 id="36">Determining the Flip Angle Used in the Thermal Equilibrium Experiment</h2><pre class="codeinput">    thermalflip = flipAnglesFromProcpar(procpart);
</pre><h2 id="37">Determining the Noise in Both Experiments</h2><p>The standard deviation of the last eighth of the points in the FIDs are found for both the real and imaginary parts in both the hyperpolarised and thermal data. The outputted noise is the average of these two components for each.</p><pre class="codeinput">    <span class="keyword">if</span> nargin &gt;= 10
        noise = findNoise(FIDs);
        avNoiseh = noise(1);
        avNoiset = noise(2);
    <span class="keyword">else</span>
        disp(<span class="string">'When prompted, enter the .txt file containing the FID data from the hyperpolarised data first then, the thermal equilibrium data'</span>)
        noise = findNoise;
        avNoiseh = noise(1);
        avNoiset = noise(2);
    <span class="keyword">end</span>
</pre><h2 id="38">Calculating the Enhancement Factor and Polarisation of Each Measured Peak</h2><p>The enhancement factor, <i>enhance</i> is defined as the ratio of the achieved Signal to Noise Ratios (SNR) from the hyperpolarised dissolution experiment to the thermal equilibrium experiment. However, before the SNR ratios can be taken, the data must be transformed so the two experiments are comparable. Signal in NMR is <i>Mxy</i>, to compare the SNR, the <i>Mxy_s from both experiments are transformed to _M0</i> using <img src="findpol_eq01996124541718814904.png" alt="$$ M0 = \frac{Mxy}{sin(alpha \times flip1)} $$"> Then, the SNR ratios are calculated. However, the thermal equilibrium SNR ratio has to be adjusted by dividing by the squareroot of the number of averages used to calculate the thermal data, since the noise scales by the squareroot of the number of averages. Polarisation is calculated by multiplying the enhancement by the polarisation at thermal equilibrium</p><pre class="codeinput">    <span class="keyword">for</span> el = 1:numpeak

        hflipfaca = sind(alpha(el)*fliph);
        hflipfac = 1/hflipfaca;
        hsigad = hypersig(1,el)*hflipfac;

        tflipfaca = sind(alpha(el)*thermalflip);
        tflipfac = 1/tflipfaca;
        tsigad = thermalsig(el)*tflipfac;

        SNRh = hsigad/avNoiseh;
        SNRt = tsigad/avNoiset;
        SNRtad = SNRt/(sqrt(numavs));

        enhance(el) = SNRh/SNRtad;

    <span class="keyword">end</span>

    pol = poltherm.*enhance;
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeoutput">
enhance =

   3.1525e+04


pol =

    0.1927


poltherm =

   6.1135e-06

</pre><h2 id="40">Notes</h2><p>The inputs used in the example were:</p><p><i>B0</i>: 7</p><p><i>atom</i>: 'C'</p><p><i>tempc</i>: 21</p><p><i>inph</i>: 'A'</p><p><i>dath</i>: {'Decay_Dissolution_1Pyr_A_10_12_19.txt'}</p><p>_procparh: 'procpar10_12_19_Dissolution_1Pyr'</p><p>_inpt: 'A'</p><p><i>datt</i>: {'Thermal_1Pyr_A_11_12_19.txt'}</p><p><i>procpart</i>: 'procpar11_12_19_Thermal_1Pyr'</p><p><i>FIDs</i>: {'Decay_DissolutionFID_1Pyr_10_12_19.txt','ThermalFID_1Pyr_11_12_19.txt'}</p><p>The example was run by putting:</p><p>[enhance,pol,poltherm] = findpol(7,'C',21,'A', {'Decay_Dissolution_1Pyr_A_10_12_19.txt'}, 'procpar10_12_19_Dissolution_1Pyr','A',{'Thermal_1Pyr_A_11_12_19.txt'}, 'procpar11_12_19_Thermal_1Pyr',{'Decay_DissolutionFID_1Pyr_10_12_19.txt', 'ThermalFID_1Pyr_11_12_19.txt'})</p><p>into the command window</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Determining Enhancement and Polarisation from DNP
%%
% _findpol_ calculates the enhancement factor and polarisation of a
% compound using dissolution data and thermal equilibrium data. From the
% magnetic field, element and temperature, the polarisation at thermal
% equilibrium is also calcualted
%%
%% Inputs
% _B0_: is the magnetic field strength of the magnet where the experiments
% were done in Tesla
%%
% _atom_: is the abbreviation of the element detected in the magnet. See
% _findgyro_ for a list of supported elements
%%
% _tempc_: is the temperature the experiments were conducted in Celsius
%%
% _inph_: is 'A' if the data from the hyperpolarsied dissolution experiment
% was quantified using AMARES from JMRUI, or it is 'M' if the data was
% quantified using integration from MestReNova
%%
% _dath_: is either a cell containing the .txt AMARES exports for the data
% from the hyperpolarised dissolution experiment in each element, or it is
% a character vector of the .csv integral custom output from MestReNova
%%
% _procparh_: is the procpar file for the hyperpolarised dissolution
% experiment
%%
% _inpt_: is 'A' if the data from the thermal equilibrium experiment was
% quantified using AMARES from JMRUI, or it is 'M' if the data was
% quantified using integration from MestReNova
%%
% _datt_: is either a cell containing the .txt AMARES exports for the data
% from the thermal equilibrium experiment in each element, or it is a
% character vector of the .csv integral custom output from MestReNova
%%
% _procpart_: is the procpar file for the thermal equilibrium experiment
%%
% _FIDs_: is a cell containing the .txt outputs from the Mrui output from
% JMRUI. Each element contains the FID data of the hyperpolarised data and
% the thermal equilibrium data respectively. 
%%
% _coilnumh_: should be left blank or equal to [] unless _inph_ is set to 
% 'M'. If _inph_ is set to 'M', _coilnumh_ is the number of coils used to 
% collect the data for the hyperpolarised experiemnt
%%
% _fieldh_: should be left blank or equal to [] unless _inph_ is set to
% 'M'. If _inph_ is set to 'M', _fieldh_ is a cell containing the names of
% each peak quantified in each element
%%
% _coilnumt_: should be left blank or equal to [] unless _inpt_ is set to
% 'M'. If _inph_ is set to 'M', _coilnumt_ is the number of coils used to
% collect the data for the thermal equilibrium experiment
%%
% _fieldt_: should be left blank or equal to [] unless _inpt_ is set to
% 'M'. If _fieldt_ is set to 'M', _fieldt_ is a cell containing the names
% of each peak quantified in each element
%% Outputs
% _enhance_: is an array containing the enhancement factors for each peak
%%
% _pol_: is an array containing the polarisation of each peak at the first
% measurement in the hyperpolarised dissolution experiment
%%
% _poltherm_: is the polarisation of the compound at thermal equilibrium
%% Child Functions
% _isnumber_: checks if an input is a number
%%
% _findgyro_: finds the gyromagnetic ratio from the inputted element
% abbreviation
%%
% _findThermalEqPol_: calculates the polarisation of the sample at
% thermoequilibrium given the magnetic field strength, gyromagnetic ratio
% and temperature
%%
% _T1DecayCalc_: calculates the flip angle correction factor to be applied
% to the hyperpolarised and thermal equilibrium data to transform the
% signal data to their respective M0s
%%
% _alphaparse_: parses data collected from the 300MHz magnet to readible
% arrays
%%
% _flipAnglesFromProcpar_: finds what is stored in the _flip1_ parameter of
% an inputted procpar file to find the estimated flip angles used
%%
% _readprocpar_: parses an inputted procpar file into a structure array
%%
% _findNoise_: finds the noise from a .txt mRUI output file from JMRUI to
% calculate the SNR. The noise is assumed to be the standard deviation of
% the last eighth of the points collected from the time domain

function [enhance,pol,poltherm] = findpol(B0,atom,tempc,inph,dath,procparh,inpt,datt,procpart,FIDs,coilnumh,fieldh,coilnumt,fieldt)

    %% Calling the User if Insufficient or Invalid Inputs
    % The magnetisation _B0_, must be a number.
    % _atom_ must be a character vector, where the gyromagnetic ratio is
    % stored in _findgyro_. _tempc_, the temperature the experiments are
    % done at must a number, like _B0_.
    
    magbool = 0;
    tempcbool = 0;
    
    if nargin > 0
        magbool = isnumber(B0);
    end
    
    while magbool == 0
        
        try
            B0 = input('Enter the magnetic field strength in Tesla the experiment was conducted in: ');
        catch
            disp('Error: Magnetic field strength must be a number')
        end
        
        magbool = isnumber(B0);
        
    end
    
    if nargin > 1
        gyro = findgyro(atom);
    else
        gyro = findgyro;
    end
    
    if nargin > 2
        tempcbool = isnumber(tempc);
    end
    
    while tempcbool == 0
        
        try
            tempc = input('Enter the temperature in Celsius the experiment was conducted in: ');
        catch
            disp('Error: Temperature must be a number')
        end
        
        tempcbool = isnumber(tempc);
        
    end
    
    %% Calculating Polarisation at Thermal Equilibrium
    
    poltherm = findThermalEqPol(B0,gyro,tempc);
    
    %% Calculating the Angle Adjustment Factor and Hyperpolarisation Signal
    % When _flip1_ is arrayed, the angles arrayed are an estimate of the
    % used flip angle from varying power. In a dissolution experiment where
    % the flip angles are varied, the data can be described by the
    % following relation:
    %%
    % $$ Mxy (Signal)_{at a time} = Mz_{at previous time measursed} \times cos(alpha \times flip1_{previous~time~measured}) \times exp(-TR/T1) \times sin(alpha \times flip1_{at~time}) $$
    %%
    % _T1DecayCalc_ calculates the parameters: _M0_ (_Mz_ at time = 0),
    % _alpha_ and _T1_. The variable _alpha_ is the angles adjustment
    % factor that is used to adjustment the proposed flip angles in _flip1_
    % to the actual flip angles used.
    
    if nargin >= 12
        [~,~,alpha] = T1DecayCalc(procparh,inph,dath,coilnumh,fieldh);
        [~,hypersig] = alphaparse([],inph,'N',dath,coilnum,field,procparh);
    elseif nargin >= 11
        [~,~,alpha] = T1DecayCalc(procparh,inph,dath,coilnumh);
        [~,hypersig] = alphaparse([],inph,'N',dath,coilnum,[],procparh);
    elseif nargin >= 6
        [~,~,alpha] = T1DecayCalc(procparh,inph,dath);
        [~,hypersig] = alphaparse([],inph,'N',dath,[],[],procparh);
    elseif nargin >= 5
        [~,~,alpha] = T1DecayCalc([],inph,dath);
        [~,hypersig] = alphaparse([],inph,'N',dath);
    elseif nargin >= 4
        [~,~,alpha] = T1DecayCalc([],inph);
        [~,hypersig] = alphaparse([],inph,'N');
    else
        [~,~,alpha] = T1DecayCalc;
        [~,hypersig] = alphaparse([],[],'N');
    end
    
    %% Determining the Flip Angle Used at the First Measured Point in the Hyperpolarised Dissolution Experiment
    
    if nargin >= 6
        flips = flipAnglesFromProcpar(procparh);
        fliph = flips(1);
    else
        flips = flipAnglesFromProcpar;
        fliph = flips(1);
    end
    
    %% Determining the Number of Averages in the Thermal Equilibrium Experiment
    
    if nargin >= 14
        [~,thermalsig] = alphaparse([],inpt,'N',datt,coilnumt,fieldt,procpart);
        numavs = readprocpar(procpart).ct;
    elseif nargin >= 13
        [~,thermalsig] = alphaparse([],inpt,'N',datt,coilnumt,[],procpart);
        numavs = readprocpar(procpart).ct;
    elseif nargin >= 9
        [~,thermalsig] = alphaparse([],inpt,'N',datt,[],[],procpart);
        numavs = readprocpar(procpart).ct;
    elseif nargin >= 8
        procpart = readprocpar;
        [~,thermalsig] = alphaparse([],inpt,'N',datt,[],[],procpart);
        numavs = readprocpar(procpart).ct;
    elseif nargin >= 7
        procpart = readprocpar;
        [~,thermalsig] = alphaparse([],inpt,'N',[],[],[],procpart);
        numavs = readprocpar(procpart).ct;
    else
        procpart = readprocpar;
        [~,thermalsig] = alphaparse([],[],'N',[],[],[],procpart);
        numavs = readprocpar(procpart).ct;
    end
    
    numpeak = length(thermalsig);
    
    enhance = zeros(numpeak,1);
    
    %% Determining the Flip Angle Used in the Thermal Equilibrium Experiment
    thermalflip = flipAnglesFromProcpar(procpart);
    
    %% Determining the Noise in Both Experiments
    % The standard deviation of the last eighth of the points in the FIDs
    % are found for both the real and imaginary parts in both the
    % hyperpolarised and thermal data. The outputted noise is the average
    % of these two components for each.
    
    if nargin >= 10
        noise = findNoise(FIDs);
        avNoiseh = noise(1);
        avNoiset = noise(2);
    else
        disp('When prompted, enter the .txt file containing the FID data from the hyperpolarised data first then, the thermal equilibrium data')
        noise = findNoise;
        avNoiseh = noise(1);
        avNoiset = noise(2);
    end
    
    %% Calculating the Enhancement Factor and Polarisation of Each Measured Peak
    % The enhancement factor, _enhance_ is defined as the ratio of the
    % achieved Signal to Noise Ratios (SNR) from the hyperpolarised
    % dissolution experiment to the thermal equilibrium experiment.
    % However, before the SNR ratios can be taken, the data must be
    % transformed so the two experiments are comparable. Signal in NMR is
    % _Mxy_, to compare the SNR, the _Mxy_s from both experiments are
    % transformed to _M0_ using $$ M0 = \frac{Mxy}{sin(alpha \times flip1)} $$
    % Then, the SNR ratios are calculated. However, the thermal equilibrium
    % SNR ratio has to be adjusted by dividing by the squareroot of the
    % number of averages used to calculate the thermal data, since the
    % noise scales by the squareroot of the number of averages.
    % Polarisation is calculated by multiplying the enhancement by the
    % polarisation at thermal equilibrium
    
    for el = 1:numpeak
        
        hflipfaca = sind(alpha(el)*fliph);
        hflipfac = 1/hflipfaca;
        hsigad = hypersig(1,el)*hflipfac;
        
        tflipfaca = sind(alpha(el)*thermalflip);
        tflipfac = 1/tflipfaca;
        tsigad = thermalsig(el)*tflipfac;
        
        SNRh = hsigad/avNoiseh;
        SNRt = tsigad/avNoiset;
        SNRtad = SNRt/(sqrt(numavs));
        
        enhance(el) = SNRh/SNRtad;
        
    end
    
    pol = poltherm.*enhance;
    
end

%% Notes
% The inputs used in the example were:
%%
% _B0_: 7
%%
% _atom_: 'C'
%%
% _tempc_: 21
%%
% _inph_: 'A'
%%
% _dath_: {'Decay_Dissolution_1Pyr_A_10_12_19.txt'}
%%
% _procparh: 'procpar10_12_19_Dissolution_1Pyr'
%%
% _inpt: 'A'
%%
% _datt_: {'Thermal_1Pyr_A_11_12_19.txt'}
%%
% _procpart_: 'procpar11_12_19_Thermal_1Pyr'
%%
% _FIDs_: {'Decay_DissolutionFID_1Pyr_10_12_19.txt','ThermalFID_1Pyr_11_12_19.txt'}
%%
% The example was run by putting:
%%
% [enhance,pol,poltherm] = findpol(7,'C',21,'A',
% {'Decay_Dissolution_1Pyr_A_10_12_19.txt'},
% 'procpar10_12_19_Dissolution_1Pyr','A',{'Thermal_1Pyr_A_11_12_19.txt'},
% 'procpar11_12_19_Thermal_1Pyr',{'Decay_DissolutionFID_1Pyr_10_12_19.txt',
% 'ThermalFID_1Pyr_11_12_19.txt'})
%%
% into the command window
##### SOURCE END #####
--></body></html>