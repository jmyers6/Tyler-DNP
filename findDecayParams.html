
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Estimating the T1 Relaxation Constand and Flip Angle Correction Factor from OLS Linearised Raw Data</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-12-09"><meta name="DC.source" content="findDecayParams.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Estimating the T1 Relaxation Constand and Flip Angle Correction Factor from OLS Linearised Raw Data</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#10">Inputs</a></li><li><a href="#13">Outputs</a></li><li><a href="#17">Setting the Minimum and Maximum <i>alpha</i> Values</a></li><li><a href="#18"><i>alpha</i> is Iterated 200 Times to Find the Best Value</a></li><li><a href="#24">Notes</a></li></ul></div><p>For each section, the data is treated as continuous and, each section is modelled with the following relation:</p><p><img src="findDecayParams_eq16003753280964755572.png" alt="$$ Mz = M0 \times cos^{t/TR}(alpha \times \theta) \times&#xA;exp\left(-\frac{t}{T1}\right) $$" style="width:222px;height:27px;"></p><p>where <i>Mz</i> represents the magnetisation in the z-direction, <i>M0</i> is the initial magnetisation in the z-direction, <i>t</i> is the time, <i>TR</i> is the average repetition time for the section (the average time interval before taking a measurement), <i>alpha</i> is the flip angle correction factor, <img src="findDecayParams_eq01864118634463401093.png" alt="$$ \theta $$" style="width:5px;height:8px;"> is the estimated flip angle found from the <i>flip1</i> parameter of the procpar file and <i>T1</i> is the longitudinal relaxation constant, which describes the decay of hyperpolarisation</p><p>The above relation is not strictly true, since signal is actually proportional to Mxy and the data is discrete with the sense of the exact time when a measurement is taken, but the relation yields a good first estimate</p><p>The model is applied to the data by linearising it using:</p><p><img src="findDecayParams_eq11782154387652640303.png" alt="$$ \ln{Mz} = \left(\frac{1}{TR}\times \ln{[cos(alpha \times \theta)]} -&#xA;\frac{1}{T1}\right)\times t+\ln{M0} $$" style="width:267px;height:27px;"></p><p>By applying a linear model to the logarithm of the signal data, the gradient of the data is:</p><p><img src="findDecayParams_eq03095922557500070029.png" alt="$$ \left(\frac{1}{TR}\times \ln{[cos(alpha \times \theta)]} -&#xA;\frac{1}{T1}\right) $$" style="width:161px;height:27px;"></p><p>This function iterates through <i>alpha</i> to find the best estimate for <i>T1</i>. The best estimate is characterised by minimising the coefficient of variation between the different sections of data</p><h2 id="10">Inputs</h2><p><i>grads</i>: is an array where each row holds the gradients for different sections of measurements for the same NMR peak. The different sections correspond to different flip angles. The columns hold data for different NMR peaks</p><p><i>flips</i>: is an array holding the values of the estimated flip angles for each section of data</p><p><i>TRs</i>: is an array holding the average repetition time for each section of data</p><h2 id="13">Outputs</h2><p><i>eT1</i>: is an array holding the best first estimate for <i>T1</i> for each peak</p><p><i>eAlpha</i>: is an array holding the best first estimate for <i>alpha</i> for each peak</p><p><i>covs</i>: is an array holding the coefficients of variations between the different secitions of data for the final estimated <i>T1</i> and <i>alpha</i> values</p><pre class="codeinput"><span class="keyword">function</span> [eT1,eAlpha,covs] = findDecayParams(grads,flips,TRs)
</pre><pre class="codeinput">    cols = length(grads(:,1));
    rows = length(grads(1,:));

    eT1 = zeros(1,rows);
    eAlpha = ones(1,rows);

    alphasa = zeros(1,rows);
    alphas = 0.001+alphasa;

    facs = ones(1,rows);
    afacs = ones(1,rows);
    afacs = 0.01*afacs;

    covs = ones(1,rows);
    covs = 10000*covs;

    iTR = 1./TRs;

    iTRs = zeros(cols,rows);

    <span class="keyword">for</span> el = 1:rows
        iTRs(:,el) = iTR;
    <span class="keyword">end</span>
</pre><h2 id="17">Setting the Minimum and Maximum <i>alpha</i> Values</h2><p><i>alpha</i> cannot ever be allowed to be zero otherwise <i>T1</i> will be undefined. In a hyperpolarisation experiment, the flip angles used can never be greater than 90&deg;, or all of the polarisation will be lost, so <i>alpha</i> is not allowed to iterate greater than <img src="findDecayParams_eq11373271954114365005.png" alt="$$ 90/(Max~Estiamted~Flip~Angle) $$" style="width:162px;height:11px;"></p><pre class="codeinput">    minAlpha = 0.001;
    maxAlphaa = max(flips);
    maxAlpha = floor(90/maxAlphaa);

    count = 0;

    avoid = [];
</pre><h2 id="18"><i>alpha</i> is Iterated 200 Times to Find the Best Value</h2><p>First <i>alpha</i> is verified to be valid, not 0 or smaller or greater than the maximum <i>alpha</i> value. If <i>alpha</i> is invalid, it is iterated until it is valid again.</p><p><i>T1</i> is calculated using:</p><p><img src="findDecayParams_eq04740591769061818558.png" alt="$$ T1 = \frac{1}{\frac{1}{TR}\times \ln{[cos(alpha\times \theta)]} -&#xA;gradient} $$" style="width:199px;height:27px;"></p><p>Since <i>T1</i> can't be negative, the first half of the denominator must be greater than the gradient. If that is not the case, <i>alpha</i> is iterated up to 1000 times until that is true. If more than 1000 iterations occur, the function gives up.</p><p>After <i>T1</i> is calcualted, the coefficient of variation (cov) is calculated for all the <i>T1_s in a section. If the cov is better than currently stored value, the estimated stored values for _alpha</i> and <i>T1</i> are set to the currently calculated values and <i>alpha</i> is iterated in the same direction as it has been going with a bigger jump than before. If that is not the case, <i>alpha</i> is iterated in the opposite direction that it had been previously with a smaller jump than the previous one.</p><pre class="codeinput">    <span class="keyword">while</span> count &lt; 200

        <span class="keyword">for</span> el = 1:rows
            <span class="keyword">while</span> alphas(el) &lt;= minAlpha
                facs(el) = 1;
                dafac = 1.2*facs(el)*afacs(el);
                alphas(el) = alphas(el)+dafac;
            <span class="keyword">end</span>
            <span class="keyword">while</span> alphas(el) &gt;= maxAlpha
                facs(el) = -1;
                dafac = 1.2*facs(el)*afacs(el);
                alphas(el) = alphas(el)+dafac;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        angle = alphas.*flips;
        coss = cosd(angle);
        lnof = coss;
        lnp = log(lnof);
        halfdenom = iTRs.*lnp;

        trut = 1;

        <span class="keyword">while</span> trut == 1

            trut = 0;

            <span class="keyword">for</span> el = 1:rows
                <span class="keyword">for</span> ele = 1:cols
                    halfdenomn = halfdenom(ele,el);
                    counter = 0;
                    bool = 0;
                    <span class="keyword">if</span> isempty(avoid) ~= 1
                        <span class="keyword">for</span> elem = 1:length(avoid)
                            <span class="keyword">if</span> el == avoid(elem)
                                bool = 1;
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                    <span class="keyword">if</span> bool == 0
                        <span class="keyword">while</span> counter &lt; 1000
                            <span class="keyword">if</span> halfdenom(ele,el) &lt;= grads(ele,el)
                                trut = 1;
                                facs(el) = -1*facs(el);
                                <span class="keyword">if</span> halfdenom(ele,el) &gt;= halfdenomn
                                    facs(el) = -1*facs(el);
                                <span class="keyword">end</span>
                                dafac = 1.2*facs(el)*afacs(el);
                                <span class="keyword">if</span> alphas(el)+dafac &lt; maxAlpha
                                    alphas(el) = alphas(el)+dafac;
                                <span class="keyword">elseif</span> alphas(el)+dafac &gt; minAlpha
                                    alphas(el) = alphas(el)+dafac;
                                <span class="keyword">else</span>
                                    counter = 1000;
                                <span class="keyword">end</span>
                                angle(:,el) = alphas(el)*flips;
                                coss = cosd(angle(ele,el));
                                lnof = coss;
                                lnp = log(lnof);
                                halfdenom(ele,el) = iTRs(ele,el)*lnp;
                                <span class="keyword">if</span> halfdenom(ele,el) &gt; halfdenomn
                                halfdenomn = halfdenom(ele,el);
                                <span class="keyword">end</span>
                                counter = counter+1;
                                <span class="keyword">if</span> counter == 1000
                                avoid = [avoid el];
                                <span class="keyword">end</span>
                            <span class="keyword">else</span>
                                counter = 1000;
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        denom = halfdenom-grads;
        T1sn = 1./denom;
        covsn = findCOV(T1sn);

        <span class="keyword">for</span> el = 1:rows
            <span class="keyword">if</span> covsn(el) &lt; covs(el)

                covs(el) = covsn(el);

                eT1(el) = mean(T1sn(:,el));
                eAlpha(el) = alphas(el);

                alphabacka = 0.1*facs(el)*afacs(el);
                alphaback = alphas(el)-alphabacka;

                anglesh = alphaback.*flips;
                cossh = cosd(anglesh);
                lnofh = cossh;
                lnph = log(lnofh);
                halfdenomh = iTRs(:,el).*lnph;
                denomh = halfdenomh-grads(:,el);

                T1snh = 1./denomh;
                covsnh = findCOV(T1snh);

                <span class="keyword">if</span> covsnh &lt; covs(el)

                    covs(el) = covsnh;

                    eT1(el) = mean(T1snh);
                    eAlpha(el) = alphaback;

                    facs(el) = -1*facs(el);
                    afacs(el) = 0.1*afacs(el);
                    afacsmove = facs(el)*afacs(el);

                    alphas(el) = alphas(el)+afacsmove;

                <span class="keyword">else</span>

                    afacs(el) = 2*afacs(el);
                    afacsmove = facs(el)*afacs(el);

                    alphas(el) = alphas(el)+afacsmove;

                <span class="keyword">end</span>

            <span class="keyword">elseif</span> covsn(el) &gt;= covs(el)

                afacs(el) = 0.9*afacs(el);
                facs(el) = -1*facs(el);
                afacsmove = facs(el)*afacs(el);

                alphas(el) = alphas(el)+afacsmove;

            <span class="keyword">end</span>
        <span class="keyword">end</span>

        count = count+1;

    <span class="keyword">end</span>

    <span class="keyword">if</span> isempty(avoid) ~= 1
        disp(<span class="string">'It was not possible to calculate T1 for peaks corresponding to the following indices '</span>)
        disp(string(avoid))
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeoutput">
eT1 =

   37.8219


eAlpha =

    1.2730


covs =

    0.1564

</pre><h2 id="24">Notes</h2><p>The inputs in the example were:</p><p><i>grads</i>: [-0.0286;-0.0520;-0.0888;-0.0284;-0.0519;-0.0875]</p><p><i>flips</i>: [5;10;15;5;10;15]</p><p><i>TRs</i>: [1;1;1;1;1;1]</p><p>The example was run by putting:</p><p>[eT1,eAlpha,covs] = findDecayParams( [-0.0286;-0.0520;-0.0888;-0.0284;-0.0519;-0.0875],[5;10;15;5;10;15], [1;1;1;1;1;1])</p><p>into the command window</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Estimating the T1 Relaxation Constand and Flip Angle Correction Factor from OLS Linearised Raw Data
%%
% For each section, the data is treated as continuous and, each section is 
% modelled with the following relation:
%% 
% $$ Mz = M0 \times cos^{t/TR}(alpha \times \theta) \times
% exp\left(-\frac{t}{T1}\right) $$
%%
% where _Mz_ represents the magnetisation in the z-direction, _M0_ is the
% initial magnetisation in the z-direction, _t_ is the time, _TR_ is the
% average repetition time for the section (the average time interval before
% taking a measurement), _alpha_ is the flip angle correction factor, $$
% \theta $$ is the estimated flip angle found from the _flip1_ parameter of
% the procpar file and _T1_ is the longitudinal relaxation constant, which
% describes the decay of hyperpolarisation
%%
% The above relation is not strictly true, since signal is actually
% proportional to Mxy and the data is discrete with the sense of the exact
% time when a measurement is taken, but the relation yields a good first
% estimate
%% 
% The model is applied to the data by linearising it using:
%%
% $$ \ln{Mz} = \left(\frac{1}{TR}\times \ln{[cos(alpha \times \theta)]} -
% \frac{1}{T1}\right)\times t+\ln{M0} $$
%%
% By applying a linear model to the logarithm of the signal data, the
% gradient of the data is:
%% 
% $$ \left(\frac{1}{TR}\times \ln{[cos(alpha \times \theta)]} -
% \frac{1}{T1}\right) $$
%%
% This function iterates through _alpha_ to find the best estimate for
% _T1_. The best estimate is characterised by minimising the coefficient of
% variation between the different sections of data
%% Inputs
% _grads_: is an array where each row holds the gradients for different
% sections of measurements for the same NMR peak. The different sections
% correspond to different flip angles. The columns hold data for different
% NMR peaks
%%
% _flips_: is an array holding the values of the estimated flip angles for
% each section of data
%%
% _TRs_: is an array holding the average repetition time for each section
% of data
%% Outputs
% _eT1_: is an array holding the best first estimate for _T1_ for each peak
%%
% _eAlpha_: is an array holding the best first estimate for _alpha_ for
% each peak
%%
% _covs_: is an array holding the coefficients of variations between the
% different secitions of data for the final estimated _T1_ and _alpha_
% values

function [eT1,eAlpha,covs] = findDecayParams(grads,flips,TRs)

    cols = length(grads(:,1));
    rows = length(grads(1,:));
    
    eT1 = zeros(1,rows);
    eAlpha = ones(1,rows);
    
    alphasa = zeros(1,rows);
    alphas = 0.001+alphasa;
    
    facs = ones(1,rows);
    afacs = ones(1,rows);
    afacs = 0.01*afacs;
    
    covs = ones(1,rows);
    covs = 10000*covs;
    
    iTR = 1./TRs;
    
    iTRs = zeros(cols,rows);
    
    for el = 1:rows
        iTRs(:,el) = iTR;
    end
    
    %% Setting the Minimum and Maximum _alpha_ Values
    % _alpha_ cannot ever be allowed to be zero otherwise _T1_ will be
    % undefined. In a hyperpolarisation experiment, the flip angles used
    % can never be greater than 90Â°, or all of the polarisation will be
    % lost, so _alpha_ is not allowed to iterate greater than $$
    % 90/(Max~Estiamted~Flip~Angle) $$
    
    minAlpha = 0.001;
    maxAlphaa = max(flips);
    maxAlpha = floor(90/maxAlphaa);
    
    count = 0;
    
    avoid = [];
    
    %% _alpha_ is Iterated 200 Times to Find the Best Value
    % First _alpha_ is verified to be valid, not 0 or smaller or greater
    % than the maximum _alpha_ value. If _alpha_ is invalid, it is iterated
    % until it is valid again.
    %%
    % _T1_ is calculated using:
    %%
    % $$ T1 = \frac{1}{\frac{1}{TR}\times \ln{[cos(alpha\times \theta)]} -
    % gradient} $$
    %%
    % Since _T1_ can't be negative, the first half of the denominator must
    % be greater than the gradient. If that is not the case, _alpha_ is
    % iterated up to 1000 times until that is true. If more than 1000
    % iterations occur, the function gives up.
    %%
    % After _T1_ is calcualted, the coefficient of variation (cov) is 
    % calculated for all the _T1_s in a section. If the cov is better than
    % currently stored value, the estimated stored values for _alpha_ and
    % _T1_ are set to the currently calculated values and _alpha_ is
    % iterated in the same direction as it has been going with a bigger
    % jump than before. If that is not the case, _alpha_ is iterated in the
    % opposite direction that it had been previously with a smaller jump
    % than the previous one.
    
    while count < 200
        
        for el = 1:rows
            while alphas(el) <= minAlpha
                facs(el) = 1;
                dafac = 1.2*facs(el)*afacs(el);
                alphas(el) = alphas(el)+dafac;
            end
            while alphas(el) >= maxAlpha
                facs(el) = -1;
                dafac = 1.2*facs(el)*afacs(el);
                alphas(el) = alphas(el)+dafac;
            end
        end
        
        angle = alphas.*flips;
        coss = cosd(angle);
        lnof = coss;
        lnp = log(lnof);
        halfdenom = iTRs.*lnp;
        
        trut = 1;
        
        while trut == 1
            
            trut = 0;
            
            for el = 1:rows
                for ele = 1:cols
                    halfdenomn = halfdenom(ele,el);
                    counter = 0;
                    bool = 0;
                    if isempty(avoid) ~= 1
                        for elem = 1:length(avoid)
                            if el == avoid(elem)
                                bool = 1;
                            end
                        end
                    end
                    if bool == 0
                        while counter < 1000
                            if halfdenom(ele,el) <= grads(ele,el)
                                trut = 1;
                                facs(el) = -1*facs(el);
                                if halfdenom(ele,el) >= halfdenomn
                                    facs(el) = -1*facs(el);
                                end
                                dafac = 1.2*facs(el)*afacs(el);
                                if alphas(el)+dafac < maxAlpha
                                    alphas(el) = alphas(el)+dafac;
                                elseif alphas(el)+dafac > minAlpha
                                    alphas(el) = alphas(el)+dafac;
                                else
                                    counter = 1000;
                                end
                                angle(:,el) = alphas(el)*flips;
                                coss = cosd(angle(ele,el));
                                lnof = coss;
                                lnp = log(lnof);
                                halfdenom(ele,el) = iTRs(ele,el)*lnp;
                                if halfdenom(ele,el) > halfdenomn
                                halfdenomn = halfdenom(ele,el);
                                end
                                counter = counter+1;
                                if counter == 1000
                                avoid = [avoid el];
                                end
                            else
                                counter = 1000;
                            end
                        end
                    end
                end
            end
            
        end
        
        denom = halfdenom-grads;
        T1sn = 1./denom;
        covsn = findCOV(T1sn);
        
        for el = 1:rows
            if covsn(el) < covs(el)
                
                covs(el) = covsn(el);
                
                eT1(el) = mean(T1sn(:,el));
                eAlpha(el) = alphas(el);
                
                alphabacka = 0.1*facs(el)*afacs(el);
                alphaback = alphas(el)-alphabacka;
                    
                anglesh = alphaback.*flips;
                cossh = cosd(anglesh);
                lnofh = cossh;
                lnph = log(lnofh);
                halfdenomh = iTRs(:,el).*lnph;
                denomh = halfdenomh-grads(:,el);
                
                T1snh = 1./denomh;
                covsnh = findCOV(T1snh);
                
                if covsnh < covs(el)
                    
                    covs(el) = covsnh;
                    
                    eT1(el) = mean(T1snh);
                    eAlpha(el) = alphaback;
                    
                    facs(el) = -1*facs(el);
                    afacs(el) = 0.1*afacs(el);
                    afacsmove = facs(el)*afacs(el);
                    
                    alphas(el) = alphas(el)+afacsmove;
                    
                else
                    
                    afacs(el) = 2*afacs(el);
                    afacsmove = facs(el)*afacs(el);
                    
                    alphas(el) = alphas(el)+afacsmove;
                    
                end
                
            elseif covsn(el) >= covs(el)
                
                afacs(el) = 0.9*afacs(el);
                facs(el) = -1*facs(el);
                afacsmove = facs(el)*afacs(el);
                
                alphas(el) = alphas(el)+afacsmove;
                
            end
        end
        
        count = count+1;
        
    end
    
    if isempty(avoid) ~= 1
        disp('It was not possible to calculate T1 for peaks corresponding to the following indices ')
        disp(string(avoid))
    end
    
end

%% Notes
% The inputs in the example were:
%%
% _grads_: [-0.0286;-0.0520;-0.0888;-0.0284;-0.0519;-0.0875]
%%
% _flips_: [5;10;15;5;10;15]
%%
% _TRs_: [1;1;1;1;1;1]
%%
% The example was run by putting:
%%
% [eT1,eAlpha,covs] = findDecayParams(
% [-0.0286;-0.0520;-0.0888;-0.0284;-0.0519;-0.0875],[5;10;15;5;10;15],
% [1;1;1;1;1;1])
%%
% into the command window
                
        
##### SOURCE END #####
--></body></html>